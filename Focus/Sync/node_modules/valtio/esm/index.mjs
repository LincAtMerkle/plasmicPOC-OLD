import ReactExports, { useRef, useCallback, useEffect, useMemo, useDebugValue } from 'react';
import { isChanged, createProxy, getUntracked } from 'proxy-compare';
import useSyncExternalStoreExports from 'use-sync-external-store/shim/index.js';
import { subscribe, snapshot } from 'valtio/vanilla';
export { getVersion, proxy, ref, snapshot, subscribe, unstable_buildProxyFunction } from 'valtio/vanilla';

const use = ReactExports.experimental_use;
const { useSyncExternalStore } = useSyncExternalStoreExports;
const affectedToPathList = (obj, affected) => {
  const list = [];
  const seen = /* @__PURE__ */ new WeakSet();
  const walk = (x, path) => {
    if (seen.has(x)) {
      return;
    }
    let used;
    if (typeof x === "object" && x !== null) {
      seen.add(x);
      used = affected.get(getUntracked(x) || x);
    }
    if (used) {
      used.forEach((key) => {
        if ("value" in (Object.getOwnPropertyDescriptor(x, key) || {})) {
          walk(x[key], path ? [...path, key] : [key]);
        }
      });
    } else if (path) {
      list.push(path);
    }
  };
  walk(obj);
  return list;
};
const useAffectedDebugValue = (state, affected) => {
  const pathList = useRef();
  useEffect(() => {
    pathList.current = affectedToPathList(state, affected);
  });
  useDebugValue(pathList.current);
};
function useSnapshot(proxyObject, options) {
  const notifyInSync = options == null ? void 0 : options.sync;
  const lastSnapshot = useRef();
  const lastAffected = useRef();
  let inRender = true;
  const currSnapshot = useSyncExternalStore(
    useCallback(
      (callback) => {
        const unsub = subscribe(proxyObject, callback, notifyInSync);
        callback();
        return unsub;
      },
      [proxyObject, notifyInSync]
    ),
    () => {
      const nextSnapshot = snapshot(proxyObject, use);
      try {
        if (!inRender && lastSnapshot.current && lastAffected.current && !isChanged(
          lastSnapshot.current,
          nextSnapshot,
          lastAffected.current,
          /* @__PURE__ */ new WeakMap()
        )) {
          return lastSnapshot.current;
        }
      } catch (e) {
      }
      return nextSnapshot;
    },
    () => snapshot(proxyObject, use)
  );
  inRender = false;
  const currAffected = /* @__PURE__ */ new WeakMap();
  useEffect(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  if ((import.meta.env && import.meta.env.MODE) !== "production") {
    useAffectedDebugValue(currSnapshot, currAffected);
  }
  const proxyCache = useMemo(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy(currSnapshot, currAffected, proxyCache);
}

export { useSnapshot };

System.register(['react', 'proxy-compare', 'use-sync-external-store/shim', 'valtio/vanilla'], (function (exports) {
  'use strict';
  var ReactExports, useRef, useCallback, useEffect, useMemo, useDebugValue, isChanged, createProxy, getUntracked, useSyncExternalStoreExports, subscribe, snapshot;
  return {
    setters: [function (module) {
      ReactExports = module.default;
      useRef = module.useRef;
      useCallback = module.useCallback;
      useEffect = module.useEffect;
      useMemo = module.useMemo;
      useDebugValue = module.useDebugValue;
    }, function (module) {
      isChanged = module.isChanged;
      createProxy = module.createProxy;
      getUntracked = module.getUntracked;
    }, function (module) {
      useSyncExternalStoreExports = module.default;
    }, function (module) {
      subscribe = module.subscribe;
      snapshot = module.snapshot;
      exports({ getVersion: module.getVersion, proxy: module.proxy, ref: module.ref, snapshot: module.snapshot, subscribe: module.subscribe, unstable_buildProxyFunction: module.unstable_buildProxyFunction });
    }],
    execute: (function () {

      exports('useSnapshot', useSnapshot);

      const use = ReactExports.experimental_use;
      const { useSyncExternalStore } = useSyncExternalStoreExports;
      const affectedToPathList = (obj, affected) => {
        const list = [];
        const seen = /* @__PURE__ */ new WeakSet();
        const walk = (x, path) => {
          if (seen.has(x)) {
            return;
          }
          let used;
          if (typeof x === "object" && x !== null) {
            seen.add(x);
            used = affected.get(getUntracked(x) || x);
          }
          if (used) {
            used.forEach((key) => {
              if ("value" in (Object.getOwnPropertyDescriptor(x, key) || {})) {
                walk(x[key], path ? [...path, key] : [key]);
              }
            });
          } else if (path) {
            list.push(path);
          }
        };
        walk(obj);
        return list;
      };
      const useAffectedDebugValue = (state, affected) => {
        const pathList = useRef();
        useEffect(() => {
          pathList.current = affectedToPathList(state, affected);
        });
        useDebugValue(pathList.current);
      };
      function useSnapshot(proxyObject, options) {
        const notifyInSync = options == null ? void 0 : options.sync;
        const lastSnapshot = useRef();
        const lastAffected = useRef();
        let inRender = true;
        const currSnapshot = useSyncExternalStore(
          useCallback(
            (callback) => {
              const unsub = subscribe(proxyObject, callback, notifyInSync);
              callback();
              return unsub;
            },
            [proxyObject, notifyInSync]
          ),
          () => {
            const nextSnapshot = snapshot(proxyObject, use);
            try {
              if (!inRender && lastSnapshot.current && lastAffected.current && !isChanged(
                lastSnapshot.current,
                nextSnapshot,
                lastAffected.current,
                /* @__PURE__ */ new WeakMap()
              )) {
                return lastSnapshot.current;
              }
            } catch (e) {
            }
            return nextSnapshot;
          },
          () => snapshot(proxyObject, use)
        );
        inRender = false;
        const currAffected = /* @__PURE__ */ new WeakMap();
        useEffect(() => {
          lastSnapshot.current = currSnapshot;
          lastAffected.current = currAffected;
        });
        {
          useAffectedDebugValue(currSnapshot, currAffected);
        }
        const proxyCache = useMemo(() => /* @__PURE__ */ new WeakMap(), []);
        return createProxy(currSnapshot, currAffected, proxyCache);
      }

    })
  };
}));
